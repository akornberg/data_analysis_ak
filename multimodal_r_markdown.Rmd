---
title: "Multimodal CITE-Seq Analysis - Rmarkdown Version 1"
author: "Adam Kornberg & Alyssa Baccarella"
date: "12/9/2019"
output: html_document
---

Input is SR's 10X Genomics run from November 2019. This experiment has two "sub-experiments": turnover and immune checkpoint blockade and was processed with two separate beads. Design of analysis is below: 


Our first step will be loading in necessary packages: 

```{r, eval=FALSE, cache=TRUE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE}
library(DESeq2)
library(ggplot2)
library(Seurat)
library(dplyr)
library(ggridges)
library(sctransform)
library(reshape2)
library(tidyr)
library(Matrix)
library(data.table)
library(EnhancedVolcano)
library(rmarkdown)
library(MAST)
```

Next we will set our working directory

```{r, message=FALSE}
setwd("~/Documents/Columbia/Han Lab/Data Analysis/SR/sr_2019_11")
```

Now we will load in the filtered gene expression matrix. These files will be found in a directory called "filtered_feature_bc_matrix". These files are gzipped (.gz) but there is no need to unzip them. 

For this specific experiment, we have two of these directories which we will call bead A (beada) and bead B (beadb). 

```{r, cache=TRUE}
sr.beada <- Read10X(data.dir = "/Users/akornberg/Documents/Columbia/Han Lab/Data Analysis/SR/sr_2019_11/gex/sample_a/filtered_feature_bc_matrix/")
sr.beadb <- Read10X(data.dir = "/Users/akornberg/Documents/Columbia/Han Lab/Data Analysis/SR/sr_2019_11/gex/sample_b/filtered_feature_bc_matrix/")
```

We have loaded in our filtered data, but will need to process this matrix to remove all genes related to T-cell receptors (variable, diversity, and joining regions for both chains). We will do this by extracting the genes detected, then search for all TCR genes by name pattern, followed by removal of these genes.

Finally, we will create a seurat object for each bead. This object will contain information on gene expression, AdT's, and metadata (HTO/TCR). 

```{r, cache=TRUE}
features.a <- sr.beada@Dimnames[[1]]
features.b <- sr.beadb@Dimnames[[1]]

features.a.tcr <- grep(c("^Trav|^Traj|^Trac|^Trbv|^Trbd|^Trbj|^Trbc"), features.a, value = TRUE)
features.b.tcr <- grep(c("^Trav|^Traj|^Trac|^Trbv|^Trbd|^Trbj|^Trbc"), features.b, value = TRUE)

sr.beada.data <- sr.beada[!rownames(sr.beada) %in% features.a.tcr, ]
sr.beadb.data <- sr.beadb[!rownames(sr.beada) %in% features.b.tcr, ]

sr.a <- CreateSeuratObject(counts = sr.beada.data, project = "sr_2019_11_a")
sr.b <- CreateSeuratObject(counts = sr.beadb.data, project="sr_2019_11_b")
```
We have our Seurat object! Next we will load in our csv files for AdT, HTO, and assignment of CD4/CD8 generated from CITE-seq-Count (available on the "CellRanger" AWS cluster). After we read these csv files, we will assign them as metadata for bead A or bead B Seurat object. 

For AdT's, we will normalize and scale them. To normalize protein data, the Satija lab does not recommend using typical log normalization and instead recommends using centered log-ration (CLR), computed independently for each feature. There may be more options for this step in the future.   

```{r, message=FALSE, cache=TRUE}
hto.a <- read.csv("/Users/akornberg/Documents/Columbia/Han Lab/Data Analysis/SR/sr_2019_11/hto/hash_labelled_beadA.csv", row.names = 1)
hto.b <- read.csv("/Users/akornberg/Documents/Columbia/Han Lab/Data Analysis/SR/sr_2019_11/hto/hash_labelled_beadB.csv", row.names = 1)

sr.a <- AddMetaData(object=sr.a, metadata = hto.a)
sr.b <- AddMetaData(object=sr.b, metadata = hto.b)

cd4.cd8.a <- read.csv("/Users/akornberg/Documents/Columbia/Han Lab/Data Analysis/SR/sr_2019_11/hto/bead_a_assigned.csv", row.names = 1)
cd4.cd8.b <- read.csv("/Users/akornberg/Documents/Columbia/Han Lab/Data Analysis/SR/sr_2019_11/hto/bead_b_assigned.csv", row.names = 1)

sr.a <- AddMetaData(object=sr.a, metadata = cd4.cd8.a)
sr.b <- AddMetaData(object=sr.b, metadata = cd4.cd8.b)

adt.a <- read.csv("/Users/akornberg/Documents/Columbia/Han Lab/Data Analysis/SR/sr_2019_11/adt/adt_beada.csv", row.names = 1)
adt.b <- read.csv("/Users/akornberg/Documents/Columbia/Han Lab/Data Analysis/SR/sr_2019_11/adt/adt_beadb.csv", row.names = 1)

sr.a[["ADT"]]<-CreateAssayObject(counts= adt.a)
sr.b[["ADT"]]<-CreateAssayObject(counts= adt.b)

sr.a<- NormalizeData(sr.a, assay = "ADT", normalization.method = "CLR")
sr.a <- ScaleData(sr.a, assay = "ADT")

shortADTnames.a<-row.names(sr.a[["ADT"]])
ADTnames.a<-paste0("adt_", shortADTnames.a)

sr.b<- NormalizeData(sr.b, assay = "ADT", normalization.method = "CLR")
sr.b <- ScaleData(sr.b, assay = "ADT")

shortADTnames.b<-row.names(sr.b[["ADT"]])
ADTnames.b<-paste0("adt_", shortADTnames.b)

```
Since the two 10X beads came from the same experiment (and were ran on the same day) we can merge them without the use of the anchoring framework available in Seurat v3 (https://satijalab.org/seurat/v3.1/integration.html). 

When we merge these samples, since certain 10X bead barcodes are detected in both samples, Seurat will add a "_1" or "_2" to bead A and bead B respectively. This will make our TCR processing slightly more difficult but we can get around it later.  

```{r, cache=TRUE}
sr.combined <- merge(sr.a, y=sr.b, project = "sr_2019_11")
```

Now we only have one Seurat object, "sr.combined". Now we will start with our TCR preprocessing from the output of CellRanger VDJ (available on AWS cluster "Cellranger"). We will do this processing in two parts.  

First lets load in the data. The output barcodes of CellRanger VDJ have a "-1" at the end of the detected barcode. We will keep these barcodes in a column called "old.barcode". Following this, we will remove the "-1" from the barcode column 

Example: (AAACCTGAGTAGCGGT-1) --> (AAACCTGAGTAGCGGT)

Next we will subset productive TCRs that have the following features:

- Full length

- Start codon

- Nonstop

- In-frame

- CDR3 exists

- Correct structure

```{r, cache=TRUE}
tcr.a <- read.csv("/Users/akornberg/Documents/Columbia/Han Lab/Data Analysis/SR/sr_2019_11/tcr/filtered_contig_annotations_b6.csv")
tcr.b <- read.csv("/Users/akornberg/Documents/Columbia/Han Lab/Data Analysis/SR/sr_2019_11/tcr/filtered_contig_annotationsB7.csv")

tcr.a$old.barcode <- tcr.a$barcode
tcr.b$old.barcode <- tcr.b$barcode

tcr.a$barcode <- gsub("-1", "", tcr.a$barcode)
tcr.b$barcode <- gsub("-1", "", tcr.b$barcode)

TCRproductive.a<-subset(tcr.a, productive == "True")
TCRproductive.b<-subset(tcr.b, productive == "True")
```
Let's see the amount of alpha vs. beta chains detected

```{r, cache = TRUE}
print(table(TCRproductive.a$chain))
print(table(TCRproductive.b$chain))
```

Now let's split or TCR into alpha or beta chains. For this analysis we will only focus on the beta chain of the TCR. 

(In this example: TRA.b refers to the alpha chain of bead B)

```{r, cache=TRUE}
splitTCR.a<-split(TCRproductive.a, TCRproductive.a$chain, drop=TRUE)
splitTCR.b<-split(TCRproductive.b, TCRproductive.b$chain, drop=TRUE)

TRA.a<-splitTCR.a[["TRA"]]
colnames(TRA.a)<-paste0("TRA.",colnames(TRA.a))

TRA.b<-splitTCR.b[["TRA"]]
colnames(TRA.b)<-paste0("TRA.",colnames(TRA.b))

TRB.a<-splitTCR.a[["TRB"]]
colnames(TRB.a)<-paste0("TRB.a",colnames(TRB.a))
TRB.a$cdr3b <- TRB.a$TRB.acdr3

TRB.b<-splitTCR.b[["TRB"]]
colnames(TRB.b)<-paste0("TRB.b",colnames(TRB.b))
TRB.b$cdr3b <- TRB.b$TRB.bcdr3
```

Now we have the productive beta chains for bead A and bead B. Let's first remove any remaining duplicated barcodes. 

After their removal we can start our TCR analysis! Using the transform function, we can calculate the amount of times a CDR3B (amino acid) sequence appears. This is a useful number but it is an absolute number and not relative (calculated as a % of total CDR3's per sample). We will turn TRB.aCDR3count into that relative number later (percentClone). We will end this step with a data frame called TRB.filtered that will only take a few more steps until it can be added as metadata.

Example: Sample A has 1000 cells, sample B has 1500 cells. If a CDR3B sequence appears 80 times in sample A and 105 times in sample B, the clone is more expanded in Sample A vs Sample B despite appearing 25 less times.

Sample A: 80/1000 --> 8% of CDR3's detected

Sample B: 105/1500 --> 7% of CDR3's detected


```{r, cache=TRUE}
toRemove.a<-table(TRB.a$TRB.abarcode)>1
removeNames.a<-names(which(toRemove.a==TRUE))
TRBfiltered.a<-subset(TRB.a, !TRB.abarcode %in% removeNames.a)

TRBfiltered.a <- transform(TRBfiltered.a, TRB.aCDR3count = ave(TRB.abarcode, TRB.acdr3, FUN = length)) 
TRBfiltered.a$TRB.aCDR3count<-as.numeric(as.character(TRBfiltered.a$TRB.aCDR3count))

toRemove.b<-table(TRB.b$TRB.bbarcode)>1
removeNames.b<-names(which(toRemove.b==TRUE))
TRBfiltered.b<-subset(TRB.b, !TRB.bbarcode %in% removeNames.b)

TRBfiltered.b <- transform(TRBfiltered.b, TRB.bCDR3count = ave(TRB.bbarcode, TRB.bcdr3, FUN = length)) 
TRBfiltered.b$TRB.bCDR3count<-as.numeric(as.character(TRBfiltered.b$TRB.bCDR3count))
```
We will also create a new factor for more highly expressed CDR3B's (in this example, any clone appearing > 10 times) 

```{r, cache=TRUE}
highClones.a<-names(which(table(TRBfiltered.a$TRB.acdr3)>10))
TRBfiltered.a$TRB.topClone<-ifelse(TRBfiltered.a$TRB.acdr3 %in% highClones.a, as.character(TRBfiltered.a$TRB.acdr3), NA)

highClones.b<-names(which(table(TRBfiltered.b$TRB.bcdr3)>10))
TRBfiltered.b$TRB.topClone<-ifelse(TRBfiltered.b$TRB.bcdr3 %in% highClones.b, as.character(TRBfiltered.b$TRB.bcdr3), NA)

```
Now it is time to process the TCR's so we can add them in as metadata. We will adjust the barcode to match that of the merged Seurat objects (bead A has "_1", bead B has "_2"). 

```{r, cache=TRUE}
TRBfiltered.a$barcode <- TRBfiltered.a$TRB.aold.barcode
TRBfiltered.b$barcode <- TRBfiltered.b$TRB.bold.barcode

barcoder <- function(df, prefix, trim="\\-1"){
  
  df$barcode <- gsub(trim, "", df$barcode)
  df$barcode <- paste0(df$barcode, prefix)
  
  df
}

TRBfiltered.a <- barcoder(TRBfiltered.a, prefix = "_1")
TRBfiltered.b <- barcoder(TRBfiltered.b, prefix = "_2")

#For an example barcode:
head(TRBfiltered.a$barcode)
head(TRBfiltered.b$barcode)
```

Let's take our corrected barcode names and get ready to add them back into the data. We will take these adjusted names and turn them into the row names, then adjust the column names of each data frame of TCR bead A and B to be able to bind them together. Finally we will add TCR data as metadata to our Seurat object!

```{r, cache = TRUE}
rownames(TRBfiltered.a)<-TRBfiltered.a$barcode
rownames(TRBfiltered.b)<-TRBfiltered.b$barcode

trb.colnames <- c("trb.barcode", "is.cell", "contig.id", "high.confidence", "length", "chain", "v.gene", "d.gene",
                  "j.gene", "c.gene", "full.length", "productive", "cdr3", "cdr3.nt", "reads", "umis", 
                  "raw.colonotype.id", "raw.consensus.id", "old.barcode", "cdr3b", "cdr3.count", "top.clone", "barcode.rowname") 

colnames(TRBfiltered.a) <- trb.colnames
colnames(TRBfiltered.b) <- trb.colnames

trb.bound <- rbind(TRBfiltered.a, TRBfiltered.b)

sr.combined<-AddMetaData(object=sr.combined, metadata = trb.bound)
sr.combined$cell.id <- rownames(sr.combined@meta.data)
```
We will leave the TCR (for now) to return to our general Seurat object.

Now let's remove "low-quality" cells: 

- Cells that are expressing a high amount of mitochondrial genes that are dying

- Cell doublets or multiplets that have an aberrantly high gene count

- Cells or empty droplets with very few genes

```{r, cache=TRUE}
sr.combined[["percentMT"]]<-PercentageFeatureSet(sr.combined, pattern = "^mt-")

plot1 <- FeatureScatter(sr.combined, feature1 = "nCount_RNA", feature2 = "percentMT") + geom_hline(yintercept = 42)
plot2 <- FeatureScatter(sr.combined, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") + geom_hline(yintercept = 5500)
CombinePlots(plots = list(plot1, plot2))

sr.combined <- subset(sr.combined, subset = nFeature_RNA > 5 & nFeature_RNA < 5500 & percentMT < 42)
```
Since there are two experiments within these two beads, we will split the Seurat object into two separate objects based on which experiment the cell was from (turnover or immune checkpoint blockade (ICB))

```{r, cache=TRUE}
sr.turnover <- subset(sr.combined, subset = experiment == "Turnover")
sr.icb <- subset(sr.combined, subset = experiment == "ICB")
```
Let's finish up our TCR analysis now: We will now calculate the relative frequency per sample of the CDR3B sequence using this loop. 

For each sample, this will calculate the total number of CDR3's detected as well as calculate the amount of times a specific CDR3B appears in this sample. This allows us to get relative frequency. We will have to perform this for both turnover and ICB experiments.   

```{r, cache=TRUE}
# FOR TURNOVER
CD3percentage<-data.frame(cell.ID=factor(),TRB.cdr3=factor(),totalDetectedTCR=numeric(),totalDetectedClone =numeric(),percentClone=numeric())

for(i in levels(as.factor(sr.turnover$mouse.turnover))){
  workingDF<-subset(sr.turnover@meta.data, mouse.turnover == i)
  resultsDF<-select(workingDF,cell.id, cdr3, trb.barcode, cdr3b)
  resultsDF$cdr3<-as.factor(as.character(resultsDF$cdr3))
  resultsDF$cdr3b<-as.factor(as.character(resultsDF$cdr3b))
  CD3countTable<- as.data.frame(table(as.factor(as.character(workingDF$cdr3))))
  CD3sum<-sum(CD3countTable$Freq)
  resultsDF$totalDetectedTCR<-CD3sum
  resultsDF$cdr3<-as.factor(as.character(resultsDF$cdr3))
  resultsDF$cdr3b<-as.factor(as.character(resultsDF$cdr3b))
  resultsDF<-merge(resultsDF,CD3countTable, by.x = "cdr3", by.y = "Var1")
  resultsDF$percentClone<-resultsDF$Freq/resultsDF$totalDetectedTCR
  CD3percentage<-rbind(CD3percentage,resultsDF)}
row.names(CD3percentage)<-CD3percentage$cell.id

#To visualize the result of this
head(CD3percentage)

sr.turnover <- AddMetaData(sr.turnover, metadata = CD3percentage)

# FOR ICB
CD3percentage2<-data.frame(cell.ID=factor(),TRB.cdr3=factor(),totalDetectedTCR=numeric(),totalDetectedClone =numeric(),percentClone=numeric())

for(i in levels(as.factor(sr.icb$mouse))){
  workingDF<-subset(sr.icb@meta.data, mouse == i)
  resultsDF<-select(workingDF,cell.id, cdr3, trb.barcode, cdr3b)
  resultsDF$cdr3<-as.factor(as.character(resultsDF$cdr3))
  resultsDF$cdr3b<-as.factor(as.character(resultsDF$cdr3b))
  CD3countTable<- as.data.frame(table(as.factor(as.character(workingDF$cdr3))))
  CD3sum<-sum(CD3countTable$Freq)
  resultsDF$totalDetectedTCR<-CD3sum
  resultsDF$cdr3<-as.factor(as.character(resultsDF$cdr3))
  resultsDF$cdr3b<-as.factor(as.character(resultsDF$cdr3b))
  resultsDF<-merge(resultsDF,CD3countTable, by.x = "cdr3", by.y = "Var1")
  resultsDF$percentClone<-resultsDF$Freq/resultsDF$totalDetectedTCR
  CD3percentage2<-rbind(CD3percentage2,resultsDF)}
row.names(CD3percentage2)<-CD3percentage2$cell.id

sr.icb <- AddMetaData(sr.icb, metadata = CD3percentage2)
```
We now have a percentClone, our relative frequency value for CDR3B's. Since a CDR3B sequence can appear in multiple samples, we will create new columns for percentClone for each sample. 

This allows us to also determine which cells have expanded/contracted between samples through an adjustable threshold. The first formula is more general while there are also formulas for calculating for just one sample. 

```{r, cache = TRUE}
# Turnover
sr.turnover$mouse <- as.factor(sr.turnover$mouse)

sr.turnover$mouse.turnover <- ifelse((sr.turnover$mouse == "C21M5 1"), "C21M5 D0 1", 
                              ifelse(sr.turnover$mouse == "C21M5 2", "C21M5 D0 2", sr.turnover$mouse.turnover))

tcr.general <- select(sr.turnover@meta.data, mouse.turnover, cdr3b, percentClone)
tcr.general$barcode <- row.names(tcr.general)

cdr3b <- levels(as.factor(tcr.general$cdr3b))

for(i in unique(as.factor(sr.turnover$mouse.turnover))){
  tcr.general[[i]]<-tcr.general[i,2] 
  tcr.general[,ncol(tcr.general)] <- ifelse((tcr.general$mouse.turnover == i), tcr.general$percentClone, NA)
  }

tcr.sample <- select(tcr.general, cdr3b, 'C18M4 D6', 'C22M5 D3', 'C22M1 D12', 'C19M3 D9', 'C22M1 D0','C21M5 D0 1',"C21M5 D0 2", 'C18M4 D0', 'C22M5 D0', 'C19M3 D0')

cdr3.sample <- as.data.frame(setDT(tcr.sample)[, lapply(.SD, function(x) sort(x)[1L]), by = .(cdr3b)])

to.merge <- select(tcr.general, cdr3b, barcode)

tcr.merged <- merge(cdr3.sample, to.merge, by = 'cdr3b', all = TRUE)

rownames(tcr.merged) <- tcr.merged$barcode
tcr.merged$barcode <- NULL
colnames(tcr.merged) <- c("cdr3", "pc.d6", "pc.d3", "pc.d12", "pc.d9", "pc.d0.d12", "pc.d0.1","pc.d0.2", "pc.d0.d6", "pc.d0.d3", "pc.d0.d9")

head(tcr.merged)

tcr.merged[,2:11][is.na(tcr.merged[,2:11])] <- 0

#Expansion // Contraction
##ADJUSTABLE THRESHOLDS
expand.threshold <- 0.05
contract.threshold <- 0.05

tcr.merged$expand <- ifelse((tcr.merged$pc.d3 > tcr.merged$pc.d0.d3 + expand.threshold), "Expand",
                 ifelse(tcr.merged$pc.d6 > tcr.merged$pc.d0.d6 + expand.threshold, "Expand",
                 ifelse(tcr.merged$pc.d9 > tcr.merged$pc.d0.d9 + expand.threshold, "Expand", 
                 ifelse(tcr.merged$pc.d12 > tcr.merged$pc.d0.d12 + expand.threshold, "Expand", "Other"))))

tcr.merged$contract <-  ifelse((tcr.merged$pc.d0.d3 > tcr.merged$pc.d3 + contract.threshold), "Contract",
                               ifelse(tcr.merged$pc.d0.d6 > tcr.merged$pc.d6 + contract.threshold, "Contact",
                                      ifelse(tcr.merged$pc.d0.d9 > tcr.merged$pc.d9 + contract.threshold, "Contract", 
                                             ifelse(tcr.merged$pc.d0.d12 > tcr.merged$pc.d12 + contract.threshold, "Contract", "Other"))))
#SPECIFIC FOR SAMPLE
tcr.merged$d3expansion <- ifelse((tcr.merged$pc.d3 > tcr.merged$pc.d0.d3 + expand.threshold), "Expand",
                                 ifelse(tcr.merged$pc.d0.d3 > tcr.merged$pc.d3 + contract.threshold, "Contract", "Other"))

tcr.merged$d6expansion <- ifelse((tcr.merged$pc.d6 > tcr.merged$pc.d0.d6 + expand.threshold), "Expand",
                                 ifelse(tcr.merged$pc.d0.d6 > tcr.merged$pc.d6 + contract.threshold, "Contract", "Other"))

tcr.merged$d9expansion <- ifelse((tcr.merged$pc.d9 > tcr.merged$pc.d0.d9 + expand.threshold), "Expand",
                                 ifelse(tcr.merged$pc.d0.d9 > tcr.merged$pc.d9 + contract.threshold, "Contract", "Other"))

tcr.merged$d12expansion <- ifelse((tcr.merged$pc.d12 > tcr.merged$pc.d0.d12 + expand.threshold), "Expand",
                                 ifelse(tcr.merged$pc.d0.d12 > tcr.merged$pc.d12 + contract.threshold, "Contract", "Other"))


sr.turnover <- AddMetaData(sr.turnover, metadata = tcr.merged)

# ICB

tcr.general <- select(sr.icb@meta.data, mouse, cdr3, percentClone)
tcr.general$barcode <- row.names(tcr.general)

cdr3 <- levels(as.factor(tcr.general$cdr3))

for(i in unique(as.factor(sr.icb$mouse))){
  tcr.general[[i]]<-tcr.general[i,2] 
  tcr.general[,ncol(tcr.general)] <- ifelse((tcr.general$mouse == i), tcr.general$percentClone, NA)
  }

tcr.sample <- select(tcr.general, cdr3, 'C13M1 PRE', 'C13M1 POST', 'C13M2 PRE', 'C13M2 POST', 'C13M3 PRE', 'C13M3 POST',
                     'C14M2 PRE', 'C14M2 POST')

cdr3.sample <- as.data.frame(setDT(tcr.sample)[, lapply(.SD, function(x) sort(x)[1L]), by = .(cdr3)])

to.merge <- select(tcr.general, cdr3, barcode)

tcr.merged <- merge(cdr3.sample, to.merge, by = 'cdr3', all = TRUE)

rownames(tcr.merged) <- tcr.merged$barcode
tcr.merged$barcode <- NULL
colnames(tcr.merged) <- c("cdr3", 'pc.C13M1.PRE', 'pc.C13M1.POST', 'pc.C13M2.PRE', 'pc.C13M2.POST', 'pc.C13M3.PRE', 'pc.C13M3.POST', 'pc.C14M2.PRE', 'pc.C14M2.POST')

head(tcr.merged)

tcr.merged[,2:9][is.na(tcr.merged[,2:9])] <- 0

#Expansion // Contraction
##ADJUSTABLE THRESHOLDS
expand.threshold <- 0.05
contract.threshold <- 0.05

tcr.merged$expand <- ifelse((tcr.merged$pc.C13M1.POST > tcr.merged$pc.C13M1.PRE + expand.threshold), "Expand",
                 ifelse(tcr.merged$pc.C13M2.POST > tcr.merged$pc.C13M2.PRE + expand.threshold, "Expand",
                 ifelse(tcr.merged$pc.C13M3.POST > tcr.merged$pc.C13M3.PRE + expand.threshold, "Expand", 
                 ifelse(tcr.merged$pc.C14M2.POST > tcr.merged$pc.C14M2.PRE + expand.threshold, "Expand", "Other"))))

tcr.merged$contract <-  ifelse((tcr.merged$pc.C13M1.PRE > tcr.merged$pc.C13M1.POST + contract.threshold), "Contract",
                               ifelse(tcr.merged$pc.C13M2.PRE > tcr.merged$pc.C13M2.POST + contract.threshold, "Contact",
                                      ifelse(tcr.merged$pc.C13M3.PRE > tcr.merged$pc.C13M3.POST + contract.threshold, "Contract", 
                                             ifelse(tcr.merged$pc.C14M2.PRE > tcr.merged$pc.C14M2.POST + contract.threshold, "Contract", "Other"))))
#SPECIFIC FOR SAMPLE
tcr.merged$C13M1expansion <- ifelse((tcr.merged$pc.C13M1.POST > tcr.merged$pc.C13M1.PRE + expand.threshold), "Expand",
                                 ifelse(tcr.merged$pc.C13M1.PRE > tcr.merged$pc.C13M1.POST + contract.threshold, "Contract", "Other"))

tcr.merged$C13M2expansion <- ifelse((tcr.merged$pc.C13M2.POST > tcr.merged$pc.C13M2.PRE + expand.threshold), "Expand",
                                 ifelse(tcr.merged$pc.C13M2.PRE > tcr.merged$pc.C13M2.POST + contract.threshold, "Contract", "Other"))

tcr.merged$C13M3expansion <- ifelse((tcr.merged$pc.C13M3.POST > tcr.merged$pc.C13M3.PRE + expand.threshold), "Expand",
                                 ifelse(tcr.merged$pc.C13M3.PRE > tcr.merged$pc.C13M3.POST + contract.threshold, "Contract", "Other"))

tcr.merged$C14M2expansion <- ifelse((tcr.merged$pc.C14M2.POST > tcr.merged$pc.C14M2.PRE + expand.threshold), "Expand",
                                 ifelse(tcr.merged$pc.C14M2.PRE > tcr.merged$pc.C14M2.POST + contract.threshold, "Contract", "Other"))

sr.icb <- AddMetaData(sr.icb, metadata = tcr.merged)

```

TCR data is finished and can be plotted at the end of the script! Before it can be plotted, we will need to generate our UMAP/t-SNE plots. We will begin with normalization of gene expression data with the sctransform wrapper in Seurat. Following the normalization, we will begin linear dimensionality reduction with PCA and generate an elbow plot to determine the dimensionality of the data.

Note: This process will take a long time, particularly with larger datasets.

```{r message=FALSE, warning=FALSE, cache=TRUE}
sr.turnover <- SCTransform(sr.turnover, vars.to.regress = c("percentMT"),  verbose = FALSE)
sr.turnover <- RunPCA(sr.turnover, verbose = FALSE)
ElbowPlot(sr.turnover, ndims= 50)
```

The elbow plot allows us to determine the dimensionality of the dataset by where the plot bends. This could be from 15-40 depending on normalization technique. With regularized negative binomial regression in sctransform, the effect of sequencing depth is mitigated allowing for us to use more PC's (30-40) when compared to the standard workflow (15-30).

Now we can run the UMAP, cluster, and plot out the turnover dataset.

```{r, cache=TRUE, message= FALSE}
sr.turnover <- RunUMAP(sr.turnover, dims = 1:30, verbose = FALSE)
sr.turnover <- FindNeighbors(sr.turnover, dims = 1:30, verbose = FALSE)
sr.turnover <- FindClusters(sr.turnover, verbose = FALSE)
DimPlot(sr.turnover, group.by = "treatment") +
  scale_color_manual(values = c("gray90", "deepskyblue2", "lightgoldenrod2", "firebrick", "navy"))

```
We can do the same for the ICB

```{r, cache=TRUE, message=FALSE, warning=FALSE}
sr.icb <- SCTransform(sr.icb, vars.to.regress = c("percentMT"), verbose = FALSE)
sr.icb <- RunPCA(sr.icb, verbose = FALSE)
ElbowPlot(sr.icb, ndims= 50)
sr.icb <- RunUMAP(sr.icb, dims = 1:40, verbose = FALSE)
sr.icb <- FindNeighbors(sr.icb, dims = 1:40, verbose = FALSE)
sr.icb <- FindClusters(sr.icb, verbose = FALSE)

DimPlot(sr.icb, group.by = "treatment_pre_post") + 
  scale_color_manual(values = c("firebrick", "pink", "navy", "deepskyblue2"))

```
Next we can split apart by CD4/8 T cells and analyze them separately by subsetting out the previously assigned CD4/8 cells
```{r, cache=TRUE}
sr.turnover.cd4 <- subset(sr.turnover, subset = label == "CD4")
sr.turnover.cd8 <- subset(sr.turnover, subset = label == "CD8")

sr.icb.cd4 <- subset(sr.icb, subset = label == "CD4")
sr.icb.cd8 <- subset(sr.icb, subset = label == "CD8")
```
Data for these are already normalized from sctransform so we can go right to linear dimensionality reduction (PCA) & nonlinear dimensionality reduction (UMAP/t-SNE)

```{r, cache=TRUE}
#Turnover
sr.turnover.cd8 <- RunPCA(sr.turnover.cd8, verbose = FALSE)
ElbowPlot(sr.turnover.cd8, ndims= 50)
sr.turnover.cd8 <- RunUMAP(sr.turnover.cd8, dims = 1:30, verbose = FALSE)
sr.turnover.cd8 <- FindNeighbors(sr.turnover.cd8, dims = 1:30, verbose = FALSE)
sr.turnover.cd8 <- FindClusters(sr.turnover.cd8, verbose = FALSE)

DimPlot(sr.turnover.cd8, group.by = "treatment", pt.size = 0.5) + 
  scale_color_manual(values = c("gray90", "deepskyblue2", "lightgoldenrod2", "firebrick", "navy"))

sr.turnover.cd4 <- RunPCA(sr.turnover.cd4, verbose = FALSE)
ElbowPlot(sr.turnover.cd4, ndims= 50)
sr.turnover.cd4 <- RunUMAP(sr.turnover.cd4, dims = 1:30, verbose = FALSE)
sr.turnover.cd4 <- FindNeighbors(sr.turnover.cd4, dims = 1:30, verbose = FALSE)
sr.turnover.cd4 <- FindClusters(sr.turnover.cd4, verbose = FALSE)

DimPlot(sr.turnover.cd4, group.by = "treatment", pt.size = 0.5) + 
  scale_color_manual(values = c("gray90", "deepskyblue2", "lightgoldenrod2", "firebrick", "navy"))

#ICB

sr.icb.cd8 <- RunPCA(sr.icb.cd8, verbose = FALSE)
ElbowPlot(sr.icb.cd8, ndims= 50)
sr.icb.cd8 <- RunUMAP(sr.icb.cd8, dims = 1:30, verbose = FALSE)
sr.icb.cd8 <- FindNeighbors(sr.icb.cd8, dims = 1:30, verbose = FALSE)
sr.icb.cd8 <- FindClusters(sr.icb.cd8, verbose = FALSE)

DimPlot(sr.icb.cd8, group.by = "treatment_pre_post", pt.size = 0.5) + 
  scale_color_manual(values = c("pink", "firebrick", "navy", "deepskyblue2"))

sr.icb.cd4 <- RunPCA(sr.icb.cd4, verbose = FALSE)
ElbowPlot(sr.icb.cd4, ndims= 50)
sr.icb.cd4 <- RunUMAP(sr.icb.cd4, dims = 1:30, verbose = FALSE)
sr.icb.cd4 <- FindNeighbors(sr.icb.cd4, dims = 1:30, verbose = FALSE)
sr.icb.cd4 <- FindClusters(sr.icb.cd4, verbose = FALSE)

DimPlot(sr.icb.cd4, group.by = "treatment_pre_post", pt.size = 0.5) + 
  scale_color_manual(values = c("pink", "firebrick", "navy", "deepskyblue2"))
```

Let's show some examples of plots we can create on top of these UMAP plots. 

General plots (for clusters)
```{r, warning=FALSE}
DimPlot(sr.turnover, pt.size = 0.5, label = TRUE)
DimPlot(sr.icb, pt.size = 0.5, label = TRUE)
```

Or if we want to plot some feature of metadata

```{r, warning=FALSE}
DimPlot(sr.turnover, group.by = "treatment", pt.size = 0.5) +
  scale_color_manual(values = c("gray90", "deepskyblue2", "lightgoldenrod2", "firebrick", "navy"))
```

Let's plot gene expression or AdT's. It is helpful to plot these separately and cutoffs can be adjusted for contrast. 

```{r, warning=FALSE}
FeaturePlot(sr.icb, features = c("Foxp3", "adt_CD4"), ncol=2, max.cutoff =)
```
Stim versus nonstim

```{r}
DimPlot(sr.icb, group.by  = "stimvnonstim", na.value = "grey90", pt.size = .5) +
  scale_color_manual(values=c("gray90", "purple4","goldenrod2"))
```
Clonality
```{r, warning=FALSE, message=FALSE}
FeaturePlot(sr.turnover.cd8, features = "CARDRGNTEVFF") +
  scale_color_gradient(low="lightgoldenrod2", high="firebrick", na.value = "grey90") +
  ggtitle("CDR3B Frequency") + theme(plot.title = element_text(hjust = 0.5))
```

This is just a brief example of the available plots. Currently in metadata (possible to view by the function):

View(object@meta.data)

We can plot any feature within there!

The next plot are diversity plots, will be useful to compare clusters. This is just among the entire population and is an example of a metadata plot that is possible.

```{r}
ggplot(sr.turnover@meta.data, aes(x=pc.d0.d9, y=pc.d9)) + geom_point() + 
  ggtitle("Day 9 Turnover") + theme(plot.title = element_text(hjust = 0.5))
```

Differential expression: This topic needs to be explored more at the given moment in determining which test is best. For nearly all of our samples, using a Wilcoxon rank sum test (the default) is not advised as our samples are not independent samples. MAST may be the best option but still needs to be explored.

For now, we will find all of the biomarkers of each cluster. There are many options to play with here that can be further explored here (https://satijalab.org/seurat/v3.1/de_vignette.html).

At the end we will also store the old identities (cluster #) as a piece of metadata
```{r, cache=TRUE, message=FALSE, warning=FALSE}
## Cluster Biomarkers
clusterMarkers <- FindAllMarkers(sr.turnover, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
topMarkers<-clusterMarkers %>% group_by(cluster) %>% top_n(n = 25, wt = avg_logFC)

shortMarkers<-clusterMarkers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
shortM<-shortMarkers[,c(6:7)]
shortM$rank<-c(1:10)
head(shortM %>% spread(rank, gene))

#Idents - Stash old idents
sr.turnover@meta.data$old.idents <- Idents(sr.turnover)
sr.icb@meta.data$old.idents <- Idents(sr.icb)

sr.turnover.cd4@meta.data$old.idents <- Idents(sr.turnover.cd4)
sr.turnover.cd8@meta.data$old.idents <- Idents(sr.turnover.cd8)

sr.icb.cd4@meta.data$old.idents <- Idents(sr.icb.cd4)
sr.icb.cd8@meta.data$old.idents <- Idents(sr.icb.cd8)

```
Let's look at the differential expression between clusters 0 and 3 in the ICB. Cluster 3 are Tregs and cluster 0 are highly expanded CD8+ T cells. 

```{r, message=FALSE, warning=FALSE, cache=TRUE}
test.marker <- FindMarkers(sr.icb, ident.1 = "0" , ident.2 = "3", logfc.threshold = , min.pct = , test.use = "MAST")

head(test.marker)
```
We can use this to create volcano plots // heatmaps // compare expression of various identities.

```{r, message=FALSE, cache=TRUE}
EnhancedVolcano(test.marker, lab=rownames(test.marker), x = "avg_logFC", y = "p_val", 
                FCcutoff = 1, 
                title = "Stim vs. Nonstim", subtitle = "SR ICB Experiment - Likelihood-Ratio Test")
```

Heatmap examples (Compare PC's or explore a list of genes)


```{r, cache=TRUE}
DimHeatmap(sr.icb, dims = 1:15, cells = 500)

features <- c("Pdcd1", "Ctla4", "Lag3", "Havcr2", "Foxp3", "Tnfrsf4", "Il2ra", "Cd40lg", "Tnf", "Tbx21")
DoHeatmap(sr.icb, group.by = "treatment_pre_post", features = features)
```

##EXTRA STUFF
```{r, message=FALSE, cache=TRUE}
tcr.cluster <- select(sr.turnover@meta.data, day, cdr3, percentClone)
tcr.cluster$barcode <- row.names(tcr.cluster)

cdr3 <- levels(as.factor(tcr.cluster$cdr3))

for(i in levels(as.factor(sr.turnover$day))){
  tcr.cluster[[i]]<-tcr.cluster[i,2] 
  tcr.cluster[,ncol(tcr.cluster)] <- ifelse((tcr.cluster$day == i), tcr.cluster$percentClone, NA)
}

colnames(tcr.cluster) <- c("seurat clusters", "cdr3", "percentClone", "barcode","cluster.0","cluster.1", "cluster.2", "cluster.3", "cluster.4", "cluster.5", "cluster.6", "cluster.7", "cluster.8", "cluster.9", "cluster.10", "cluster.11", "cluster.12")
cluster.sample <- select(tcr.cluster, cdr3,D0_1, D0_2, D3_1,D3_2,D6_1,D6_2,D9_1,D9_2,D12_1,D12_2)

cdr3.cluster <- as.data.frame(setDT(cluster.sample)[, lapply(.SD, function(x) sort(x)[1L]), by = .(cdr3)])

to.merge <- select(tcr.cluster, cdr3, barcode)

tcr.merged.clusters <- merge(cdr3.cluster, to.merge, by = 'cdr3', all = TRUE)

rownames(tcr.merged.clusters) <- tcr.merged.clusters$barcode
tcr.merged.clusters$barcode <- NULL

tcr.merged.clusters[,2:ncol(tcr.merged.clusters)][is.na(tcr.merged.clusters[,2:ncol(tcr.merged.clusters)])] <- 0

sr.turnover <- AddMetaData(sr.turnover, metadata = tcr.merged.clusters)

View(sr.turnover@meta.data)
sr.turnover$shared <- ifelse((sr.turnover$D0_1 > 0 & sr.turnover$D0_2 > 0), "Shared",
         ifelse(sr.turnover$D3_1 > 0 & sr.turnover$D3_2 > 0, "Shared",
         ifelse(sr.turnover$D6_1 > 0 & sr.turnover$D6_2 > 0, "Shared",
         ifelse(sr.turnover$D9_1 > 0 & sr.turnover$D9_2 > 0, "Shared",
         ifelse(sr.turnover$D12_1 > 0 & sr.turnover$D12_2 > 0, "Shared", NA)))))
sr.turnover$turnover.day <- factor(sr.turnover$day, levels = unique(sr.turnover$day))
sr.turnover$turnover.day <- factor(sr.turnover$turnover.day, levels =c("D0_1", "D0_2", "D3_1", "D3_2", "D6_1","D6_2", "D9_1","D9_2","D12_1","D12_2"))
#Take Total barcodes with CDR3B's - Then only unique 
test <- select(sr.turnover@meta.data, cdr3, percentClone, turnover.day, day, seurat_clusters)
test2 <- na.omit(test)
test3 <- unique(test2)
test3$pC <- test3$percentClone*100

test3$Y1 <- cut(test3$pC, breaks=c(0, 0.1488, 0.5633, 1.1904, 5, 20))
test3$Y2 <- cut(test3$pC, breaks=c(0,0.01, 0.25, 0.5,1, 2, 20))
test3$Y3 <- cut(test3$pC, breaks=6)

ggplot(test3, aes(x = turnover.day, y = cdr3)) + 
  geom_tile(aes(fill = Y2), colour= "white") + 
  scale_fill_brewer(palette = "OrRd") +
  theme(panel.grid.minor=element_blank(), axis.text.y =element_text(size = 1))

df <- select(sr.turnover@meta.data, cdr3, percentClone,day, shared, turnover.day,seurat_clusters)
df <- na.omit(df)
df <- unique(df)
df$pC <- df$percentClone*100

df$Y1 <- cut(df$pC, breaks=c(0, 0.1488, 0.5633, 1.1904, 5, 20))
df$Y2 <- cut(df$pC, breaks=c(0, 0.5,1, 2, 20))
df$Y3 <- cut(df$pC, breaks=6)

ggplot(df, aes(x = turnover.day, y = cdr3)) + 
  geom_tile(aes(fill = Y2), colour= "white") + 
  scale_fill_brewer(palette = "OrRd") +
  theme(panel.grid.minor=element_blank(), axis.text.y =element_text(size = 4))

#Specific Day  
df$d0 <- ifelse((df$day == "D0_1"), "D0_1", ifelse(df$day == "D0_2", "D0_2", NA))
df$d3 <- ifelse((df$day == "D3_1"), "D3_1", ifelse(df$day == "D3_2", "D3_2", NA))
df$d6 <- ifelse((df$day == "D6_1"), "D6_1", ifelse(df$day == "D6_2", "D6_2", NA))
df$d9 <- ifelse((df$day == "D9_1"), "D9_1", ifelse(df$day == "D9_2", "D9_2", NA))
df$d12 <- ifelse((df$day == "D12_1"), "D12_1", ifelse(df$day == "D12_2", "D12_2", NA))

ggplot(df, aes(x = d9, y = cdr3)) + 
  geom_tile(aes(fill = Y2), colour= "white") + 
  scale_fill_brewer(palette = "OrRd") +
  theme(panel.grid.minor=element_blank(), axis.text.y =element_text(size = 4))

#Clusters
ggplot(df, aes(x = turnover.day, y = cdr3)) + 
  geom_tile(aes(fill = seurat_clusters), colour= "white") +
  theme(panel.grid.minor=element_blank(), axis.text.y =element_text(size = 4))
  scale_fill_manual(values= c("gray90", "gray90", "gray90", "gray90","gray90",
                              "gray90", "gray90", "firebrick","navy", "gray90", "gray90",
                              "gray90","gray90", "gray90", "gray90", "gray90","gray90", 
                              "gray90", "gray90", "gray90"))
  
##Create Identity of Clonally Expanded
# "Expansions" - Not giving a TCR credit for appearing just once
sr.turnover$expansions <- sr.turnover$Freq - 1
sr.turnover$expansionfreq <- sr.turnover$expansions / sr.turnover$totalDetectedTCR
sr.turnover$expansion_de <- sr.turnover$expansionfreq
sr.turnover$expansionfreq[sr.turnover$expansionfreq == 0] <- NA


DimPlot(sr.turnover, group.by  = , na.value = "grey90", pt.size = .25, label = TRUE) 

FeaturePlot(sr.turnover, features = "expansionfreq") +
  scale_color_gradient(low="lightgoldenrod2", high="firebrick", na.value = "grey90") +
  ggtitle("CDR3B Expansion Frequency") + theme(plot.title = element_text(hjust = 0.5))

# Clonally Expanded DE #OnWisconsin #wiscONsin #GoBadgers #FuckEmBucky #Badge #RollBadge #UDub #BigBadBadgers
sr.turnover$expanded.10p <- ifelse((sr.turnover$expansion_de >= 0.10), "Expanded > 10%","Other")
sr.turnover$expanded.5p <-  ifelse((sr.turnover$expansion_de >= 0.05), "Expanded > 5%","Other")

#What are the current identities of the cells?
head(Idents(sr.turnover))

#Store old Idents as a column of metadata
sr.turnover$old.idents <- Idents(sr.turnover)

#Change the identities of the cells
Idents(sr.turnover) <- sr.turnover$expanded.10p

#DE on Cells > 10% expansion
cluster.10p<- FindMarkers(sr.turnover, ident.1 = "Expanded > 10%" ,ident.2= "Other", logfc.threshold = 0.25, test.use = "MAST")


# Shared Expanded  
sr.turnover$shared.day <- ifelse((sr.turnover$D0_1 > 0 & sr.turnover$D0_2 > 0 & sr.turnover$turnover.day == "D0_1"), "Shared D0_1",
                          ifelse(sr.turnover$D0_1 > 0 & sr.turnover$D0_2 > 0 & sr.turnover$turnover.day == "D0_2", "Shared D0_2",
                          ifelse(sr.turnover$D3_1 > 0 & sr.turnover$D3_2 > 0 & sr.turnover$turnover.day == "D3_1", "Shared D3_1",
                          ifelse(sr.turnover$D3_1 > 0 & sr.turnover$D3_2 > 0 & sr.turnover$turnover.day == "D3_2", "Shared D3_2",
                          ifelse(sr.turnover$D6_1 > 0 & sr.turnover$D6_2 > 0 & sr.turnover$turnover.day == "D6_1", "Shared D6_1", 
                          ifelse(sr.turnover$D6_1 > 0 & sr.turnover$D6_2 > 0 & sr.turnover$turnover.day == "D6_2", "Shared D6_2",
                          ifelse(sr.turnover$D9_1 > 0 & sr.turnover$D9_2 > 0 & sr.turnover$turnover.day == "D9_1", "Shared D9_1",
                          ifelse(sr.turnover$D9_1 > 0 & sr.turnover$D9_2 > 0 & sr.turnover$turnover.day == "D9_2", "Shared D9_2",
                          ifelse(sr.turnover$D12_1 > 0 & sr.turnover$D12_2 > 0 & sr.turnover$turnover.day == "D12_1", "Shared D12_1",
                          ifelse(sr.turnover$D12_1 > 0 & sr.turnover$D12_2 > 0 & sr.turnover$turnover.day == "D12_2", "Shared D12_2", "Unshared"))))))))))

DimPlot(sr.turnover, group.by = "shared.day", pt.size = 0.5, na.value = "grey90", order = c("Shared D12_1", "Shared D12_2")) + 
  ggtitle("Shared") + theme(plot.title = element_text(hjust = 0.5)) + 
  scale_color_manual(values=c("gray90", "gray90", "gray90", "gray90", "gray90", "gray90",
                              "gray90", "gray90", "gray90", "darkorange", "purple4"))

ggplot(sr.turnover@meta.data, aes(x=D6_1, y=D6_2)) + geom_jitter() + geom_density2d() + 
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_x_continuous(limits = c(0,0.2)) +
  scale_y_continuous(limits=c(0,0.2))



div <- select(sr.turnover@meta.data, turnover.day, D0_1, D0_2, D3_1,D3_2, D6_1, D6_2, D9_1, D9_2, D12_1, D12_2)
div <- na.omit(div)
div <- unique(div)
row.names(div) <- div$cdr3

counts <- ddply(div, .(div$D0_1, div$D0_2), nrow)
names(counts) <- c("D0_1", "D0_2", "Freq")

p0 <- ggplot(counts, aes(x=D0_1, y=D0_2)) + geom_jitter() + geom_density2d() + 
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_x_continuous(limits = c(0,0.2)) +
  scale_y_continuous(limits=c(0,0.2))

CombinePlots(plots = list(p0,p3,p6,p9,p12), ncol = 5)

# Shared by Mouse
tcr.cluster <- select(sr.icb@meta.data, mouse, cdr3, percentClone)
tcr.cluster$barcode <- row.names(tcr.cluster)

cdr3 <- levels(as.factor(tcr.cluster$cdr3))

for(i in levels(as.factor(sr.icb$mouse))){
  tcr.cluster[[i]]<-tcr.cluster[i,2] 
  tcr.cluster[,ncol(tcr.cluster)] <- ifelse((tcr.cluster$mouse == i), tcr.cluster$percentClone, NA)
}

cluster.sample <- select(tcr.cluster, cdr3,"C13M1POST","C13M1PRE","C13M2POST","C13M2PRE","C13M3POST","C13M3PRE","C14M2POST","C14M2PRE")

cdr3.cluster <- as.data.frame(setDT(cluster.sample)[, lapply(.SD, function(x) sort(x)[1L]), by = .(cdr3)])

to.merge <- select(tcr.cluster, cdr3, barcode)

tcr.merged.clusters <- merge(cdr3.cluster, to.merge, by = 'cdr3', all = TRUE)

rownames(tcr.merged.clusters) <- tcr.merged.clusters$barcode
tcr.merged.clusters$barcode <- NULL

tcr.merged.clusters[,2:ncol(tcr.merged.clusters)][is.na(tcr.merged.clusters[,2:ncol(tcr.merged.clusters)])] <- 0

sr.icb <- AddMetaData(sr.icb, metadata = tcr.merged.clusters)

View(sr.icb@meta.data)

sr.icb$shared <- ifelse((sr.icb$C13M1PRE > 0 & sr.icb$C13M1POST > 0), "Shared",
                 ifelse(sr.icb$C13M2PRE > 0 & sr.icb$C13M2POST > 0, "Shared",
                 ifelse(sr.icb$C13M3PRE > 0 & sr.icb$C13M3POST > 0, "Shared",
                 ifelse(sr.icb$C14M2PRE > 0 & sr.icb$C14M2POST > 0, "Shared", NA))))
DimPlot(sr.icb, group.by = "shared", pt.size = 0.5, na.value = "grey90") + 
  ggtitle("Shared") + theme(plot.title = element_text(hjust = 0.5)) + 
  scale_color_manual(values=c("gray90", "gray90", "gray90", "gray90", "gray90", "gray90",
                              "gray90", "gray90", "gray90", "darkorange", "purple4"))

sr.icb$mouse.day <- as.factor(sr.icb$mouse)

sr.icb$shared.day <- ifelse((sr.icb$C13M1PRE > 0 & sr.icb$C13M1POST > 0 & sr.icb$mouse.day == "C13M1PRE"), "Shared PC PRE",
                     ifelse(sr.icb$C13M1PRE > 0 & sr.icb$C13M1POST > 0 & sr.icb$mouse.day == "C13M1POST", "Shared PC POST", 
                     ifelse(sr.icb$C13M2PRE > 0 & sr.icb$C13M2POST > 0 & sr.icb$mouse.day == "C13M2PRE", "Shared PC PRE",
                     ifelse(sr.icb$C13M2PRE > 0 & sr.icb$C13M2POST > 0 & sr.icb$mouse.day == "C13M2POST", "Shared PC POST",
                     ifelse(sr.icb$C13M3PRE > 0 & sr.icb$C13M3POST > 0 & sr.icb$mouse.day == "C13M3PRE", "Shared PBS PRE",
                     ifelse(sr.icb$C13M3PRE > 0 & sr.icb$C13M3POST > 0 & sr.icb$mouse.day == "C13M3POST", "Shared PBS POST", 
                     ifelse(sr.icb$C14M2PRE > 0 & sr.icb$C14M2POST > 0 & sr.icb$mouse.day == "C14M2PRE", "Shared PC PRE",
                     ifelse(sr.icb$C14M2PRE > 0 & sr.icb$C14M2POST > 0 & sr.icb$mouse.day == "C14M2POST", "Shared PC POST", "Unshared"))))))))
                     
DimPlot(sr.icb, group.by = "shared.day", pt.size = 0.5, na.value = "grey90")) + 
  ggtitle("Shared") + theme(plot.title = element_text(hjust = 0.5)) + 
  scale_color_manual(values=c("gray90", "gray90", "gray90", "gray90", "gray90", "gray90",
                              "gray90", "gray90", "gray90", "darkorange", "purple4"))                     
# EXPANSION or CONTRACTION
expand.threshold <- 0.05
contract.threshold <- 0.05

sr.icb$expand <- ifelse((sr.icb$C13M1POST > sr.icb$C13M1PRE + expand.threshold), "Expand",
                 ifelse(sr.icb$C13M2POST > sr.icb$C13M2PRE + expand.threshold, "Expand",
                 ifelse(sr.icb$C13M3POST > sr.icb$C13M3PRE + expand.threshold, "Expand", 
                 ifelse(sr.icb$C14M2POST > sr.icb$C14M2PRE + expand.threshold, "Expand", "Other"))))

sr.icb$contract <-  ifelse((sr.icb$C13M1PRE > sr.icb$C13M1POST + contract.threshold), "Contract",
                    ifelse(sr.icb$C13M2PRE > sr.icb$C13M2POST + contract.threshold, "Contact",
                    ifelse(sr.icb$C13M3PRE > sr.icb$C13M3POST + contract.threshold, "Contract", 
                    ifelse(sr.icb$C14M2PRE > sr.icb$C14M2POST + contract.threshold, "Contract", "Other"))))

DimPlot(sr.icb, group.by = "expand", pt.size = 0.5, na.value = "grey90")) + 
  ggtitle("Expansion") + theme(plot.title = element_text(hjust = 0.5)) + 
  scale_color_manual(values=c("gray90", "gray90", "gray90", "gray90", "gray90", "gray90",
                              "gray90", "gray90", "gray90", "darkorange", "purple4"))  


```

 
